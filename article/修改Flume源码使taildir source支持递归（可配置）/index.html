<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style-dark.css?v=2.0.5"><link rel="stylesheet" type="text/css" href="/css/highlight-dark.css?v=2.0.5"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><title>修改Flume源码使taildir source支持递归（可配置） | 暗也橙子Blog</title></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">修改Flume源码使taildir source支持递归（可配置）</h1><a id="logo" href="/.">暗也橙子Blog</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">修改Flume源码使taildir source支持递归（可配置）</h1><div class="post-meta"><a href="/article/修改Flume源码使taildir source支持递归（可配置）/#comments" class="comment-count"></a><p><span class="date">Mar 06, 2020</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h3 id="修改flume源码使taildir-source支持递归可配置">修改Flume源码使taildir source支持递归（可配置）</h3>
<hr>
<h4 id="taildir">taildir</h4>
<p>Flume的source选哪个？taildir source首选！<br>
1.断点还原 positionFile可以记录偏移量<br>
2.可配置文件组，里面使用正则表达式配置多个要监控的文件<br>
这么好的taildir source有一点不完美，只支持监控一级目录下的文件，不能支持递归监控文件夹。<br>
例如：<br>
/log/login/20200306/1.1og<br>
/log/login/20200307/1.1og<br>
这两个文件无法用taildir采集<br>
为实现目录递归, 即可以同时监控子目录，让上述两个文件可以通过/log/login/*.log采集，就只能修改源代码了。</p>
<h4 id="改源码先读源码">改源码，先读源码</h4>
<p>Flume的taildir source启动会调用start()方法作初始化，里面创建一个ReliableTaildirEventReader,这里用到了建造者模式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public synchronized <span class="keyword">void</span> start() &#123;</span><br><span class="line">    logger.info(<span class="string">"&#123;&#125; TaildirSource source starting with directory: &#123;&#125;"</span>, getName(), filePaths);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      reader = <span class="keyword">new</span> ReliableTaildirEventReader.Builder()</span><br><span class="line">          .filePaths(filePaths)</span><br><span class="line">          .headerTable(headerTable)</span><br><span class="line">          .positionFilePath(positionFilePath)</span><br><span class="line">          .skipToEnd(skipToEnd)</span><br><span class="line">          .addByteOffset(byteOffsetHeader)</span><br><span class="line">          .cachePatternMatching(cachePatternMatching)</span><br><span class="line">          .annotateFileName(fileHeader)</span><br><span class="line">          .fileNameHeader(fileHeaderKey)</span><br><span class="line">          .build();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> FlumeException(<span class="string">"Error instantiating ReliableTaildirEventReader"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    idleFileChecker = Executors.newSingleThreadScheduledExecutor(</span><br><span class="line">        <span class="keyword">new</span> ThreadFactoryBuilder().setNameFormat(<span class="string">"idleFileChecker"</span>).build());</span><br><span class="line">    idleFileChecker.scheduleWithFixedDelay(<span class="keyword">new</span> idleFileCheckerRunnable(),</span><br><span class="line">        idleTimeout, checkIdleInterval, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">    positionWriter = Executors.newSingleThreadScheduledExecutor(</span><br><span class="line">        <span class="keyword">new</span> ThreadFactoryBuilder().setNameFormat(<span class="string">"positionWriter"</span>).build());</span><br><span class="line">    positionWriter.scheduleWithFixedDelay(<span class="keyword">new</span> PositionWriterRunnable(),</span><br><span class="line">        writePosInitDelay, writePosInterval, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>.start();</span><br><span class="line">    logger.debug(<span class="string">"TaildirSource started"</span>);</span><br><span class="line">    sourceCounter.start();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>taildir source属于PollableSource，下面是PollableSource的文档注释：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A &#123;@link Source&#125; that requires an external driver to poll to determine</span></span><br><span class="line"><span class="comment"> * whether there are &#123;@linkplain Event events&#125; that are available to ingest</span></span><br><span class="line"><span class="comment"> * from the source.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @see org.apache.flume.source.EventDrivenSourceRunner</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public interface PollableSource extends Source &#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>这段注释的意思是PollableSource是需要一个外部驱动去查看有没有需要消费的事件，从而拉取事件，讲白了就是定时拉取。所以flume也不一定是真正实时的，只是隔一会儿不停地来查看事件而已(与之相应的是另一种EventDrivenSourceRunner)。<br>
那么taildir source在定时拉取事件的时候是调用的process方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public Status process() &#123;</span><br><span class="line">    Status status = Status.READY;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      existingInodes.clear();</span><br><span class="line">      existingInodes.addAll(reader.updateTailFiles());</span><br><span class="line">      <span class="keyword">for</span> (long inode : existingInodes) &#123;</span><br><span class="line">        TailFile tf = reader.getTailFiles().get(inode);</span><br><span class="line">        <span class="keyword">if</span> (tf.needTail()) &#123;</span><br><span class="line">          tailFileProcess(tf, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      closeTailFiles();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(retryInterval);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        logger.info(<span class="string">"Interrupted while sleeping"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      logger.error(<span class="string">"Unable to tail files"</span>, t);</span><br><span class="line">      status = Status.BACKOFF;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>重点就是下面这几行:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">existingInodes.addAll(reader.updateTailFiles());</span><br><span class="line">    <span class="keyword">for</span> (long inode : existingInodes) &#123;</span><br><span class="line">      TailFile tf = reader.getTailFiles().get(inode);</span><br><span class="line">      <span class="keyword">if</span> (tf.needTail()) &#123;</span><br><span class="line">        tailFileProcess(tf, <span class="literal">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>从reader.updateTailFiles()获取需要监控的文件，然后对每一个进行处理，查看最后修改时间，判定是否需要tail，需要tail就tail。<br>
那么进入reader.updateTailFiles()</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (File f : taildir.getMatchingFiles()) &#123;</span><br><span class="line">        long inode;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          inode = getInode(f);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFileException e) &#123;</span><br><span class="line">          logger.info(<span class="string">"File has been deleted in the meantime: "</span> + e.getMessage());</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TailFile tf = tailFiles.get(inode);</span><br><span class="line">        <span class="keyword">if</span> (tf == <span class="literal">null</span> || !tf.getPath().equals(f.getAbsolutePath())) &#123;</span><br><span class="line">          long startPos = skipToEnd ? f.length() : <span class="number">0</span>;</span><br><span class="line">          tf = openFile(f, headers, inode, startPos);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		...</span><br></pre></td></tr></table></figure>
<p>遍历每一个正则表达式匹配对应的匹配器，每个匹配器去获取匹配的文件！taildir.getMatchingFiles()</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">List&lt;File&gt; getMatchingFiles() &#123;</span><br><span class="line">    long now = TimeUnit.SECONDS.toMillis(</span><br><span class="line">        TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis()));</span><br><span class="line">    long currentParentDirMTime = parentDir.lastModified();</span><br><span class="line">    List&lt;File&gt; result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// calculate matched files if</span></span><br><span class="line">    <span class="comment">// - we don't want to use cache (recalculate every time) OR</span></span><br><span class="line">    <span class="comment">// - directory was clearly updated after the last check OR</span></span><br><span class="line">    <span class="comment">// - last mtime change wasn't already checked for sure</span></span><br><span class="line">    <span class="comment">//   (system clock hasn't passed that second yet)</span></span><br><span class="line">    <span class="keyword">if</span> (!cachePatternMatching ||</span><br><span class="line">        lastSeenParentDirMTime &lt; currentParentDirMTime ||</span><br><span class="line">        !(currentParentDirMTime &lt; lastCheckedTime)) &#123;</span><br><span class="line">      lastMatchedFiles = sortByLastModifiedTime(getMatchingFilesNoCache(isRecursive));</span><br><span class="line">      lastSeenParentDirMTime = currentParentDirMTime;</span><br><span class="line">      lastCheckedTime = now;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lastMatchedFiles;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到getMatchingFilesNoCache(isRecursive)就是获取匹配的文件的方法，也就是需要修改的方法了！<br>
ps：这里的isRecursive是我加的~<br>
点进去：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private List&lt;File&gt; getMatchingFilesNoCache() &#123;</span><br><span class="line">  List&lt;File&gt; result = Lists.newArrayList();</span><br><span class="line">  <span class="keyword">try</span> (DirectoryStream&lt;Path&gt; stream = Files.newDirectoryStream(parentDir.toPath(), fileFilter)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Path entry : stream) &#123;</span><br><span class="line">      result.add(entry.toFile());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    logger.error(<span class="string">"I/O exception occurred while listing parent directory. "</span> +</span><br><span class="line">                 <span class="string">"Files already matched will be returned. "</span> + parentDir.toPath(), e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>源码是用了Files.newDirectoryStream(parentDir.toPath(), fileFilter))，将父目录下符合正则表达式的文件都添加到一个迭代器里。（这里还用了try (…)的语法糖）</p>
<h4 id="找到地方了开始改">找到地方了，开始改</h4>
<p>在getMatchingFilesNoCache()方法下面加一个重载的方法, 可增加扩展性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private List&lt;File&gt; getMatchingFilesNoCache(boolean recursion) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!recursion) &#123;</span><br><span class="line">        <span class="keyword">return</span> getMatchingFilesNoCache();</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;File&gt; result = Lists.newArrayList();</span><br><span class="line">    <span class="comment">// 使用非递归的方式遍历文件夹</span></span><br><span class="line">    Queue&lt;File&gt; dirs = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">    dirs.offer(parentDir);</span><br><span class="line">    <span class="keyword">while</span> (dirs.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        File dir = dirs.poll();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DirectoryStream&lt;Path&gt; stream = Files.newDirectoryStream(dir.toPath(), fileFilter);</span><br><span class="line">            stream.forEach(path -&gt; result.add(path.toFile()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            logger.error(<span class="string">"I/O exception occurred while listing parent directory. "</span> +</span><br><span class="line">                    <span class="string">"Files already matched will be returned. (recursion)"</span> + parentDir.toPath(), e);</span><br><span class="line">        &#125;</span><br><span class="line">        File[] dirList = dir.listFiles();</span><br><span class="line">        assert dirList != <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (File f : dirList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (f.isDirectory()) &#123;</span><br><span class="line">                dirs.add(f);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用了非递归的方式遍历文件夹，就是树到队列的转换。<br>
到这里，核心部分就改完了，接下来要处理这个recursion的参数。</p>
<h4 id="华丽的分割线后顺腾摸瓜">华丽的分割线后，顺腾摸瓜</h4>
<p>一路改构造方法，添加这个参数，最终参数从哪来呢？<br>
flume的source启动时会调用configure方法，将Context中的内容配置进reader等对象中。<br>
isRecursive = context.getBoolean(RECURSIVE, DEFAULT_RECURSIVE);<br>
context从TaildirSourceConfigurationConstants中获取配置名和默认值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Whether to support recursion. */</span></span><br><span class="line">public <span class="keyword">static</span> final <span class="built_in">String</span> RECURSIVE = <span class="string">"recursive"</span>;</span><br><span class="line">public <span class="keyword">static</span> final boolean DEFAULT_RECURSIVE = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<p>这里的recursive也就是flume配置文件里配置项了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Whether to support recusion</span><br><span class="line">a1.sources.r1.recursive = <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h4 id="大功告成打包试试">大功告成，打包试试</h4>
<p>执行package将其放在flume的lib下，替换原来的flume-taildir-source***.jar<br>
启动，测试，成功！</p>
</div><div class="post-copyright"><blockquote><p>原文作者: 暗也橙子</p><p>原文链接: <a href="https://zzuuriel.github.io/article/修改Flume源码使taildir source支持递归（可配置）/">https://zzuuriel.github.io/article/修改Flume源码使taildir source支持递归（可配置）/</a></p><p>版权声明: 转载请注明出处(必须保留作者署名及链接)</p></blockquote></div><div class="tags"><a href="/tags/Flume/">Flume</a></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/article/解决Spark on YARN时jar包乱飞的问题/" class="next">解决Spark on YARN时jar包乱飞的问题</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#修改flume源码使taildir-source支持递归可配置"><span class="toc-text">&#x4FEE;&#x6539;Flume&#x6E90;&#x7801;&#x4F7F;taildir source&#x652F;&#x6301;&#x9012;&#x5F52;&#xFF08;&#x53EF;&#x914D;&#x7F6E;&#xFF09;</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#taildir"><span class="toc-text">taildir</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#改源码先读源码"><span class="toc-text">&#x6539;&#x6E90;&#x7801;&#xFF0C;&#x5148;&#x8BFB;&#x6E90;&#x7801;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#找到地方了开始改"><span class="toc-text">&#x627E;&#x5230;&#x5730;&#x65B9;&#x4E86;&#xFF0C;&#x5F00;&#x59CB;&#x6539;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#华丽的分割线后顺腾摸瓜"><span class="toc-text">&#x534E;&#x4E3D;&#x7684;&#x5206;&#x5272;&#x7EBF;&#x540E;&#xFF0C;&#x987A;&#x817E;&#x6478;&#x74DC;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#大功告成打包试试"><span class="toc-text">&#x5927;&#x529F;&#x544A;&#x6210;&#xFF0C;&#x6253;&#x5305;&#x8BD5;&#x8BD5;</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/article/修改Flume源码使taildir source支持递归（可配置）/">修改Flume源码使taildir source支持递归（可配置）</a></li><li class="post-list-item"><a class="post-list-link" href="/article/解决Spark on YARN时jar包乱飞的问题/">解决Spark on YARN时jar包乱飞的问题</a></li><li class="post-list-item"><a class="post-list-link" href="/article/Flink之Watermark理解/">Flink之Watermark理解</a></li><li class="post-list-item"><a class="post-list-link" href="/article/2.spark-2.4.5-bin-2.6.0-cdh5.15.1.tgz/"> Spark-2.4.5源码编译</a></li><li class="post-list-item"><a class="post-list-link" href="/article/Flink自定义触发器/">Flink自定义触发器</a></li><li class="post-list-item"><a class="post-list-link" href="/article/60.深入理解Spark算子aggregate/">深入理解Spark算子aggregate</a></li><li class="post-list-item"><a class="post-list-link" href="/article/60.Kudu常用Api(java)/">Kudu常用Api(java) </a></li><li class="post-list-item"><a class="post-list-link" href="/article/60.CentOS7安装单机版Kudu/">CentOS7安装单机版Kudu </a></li><li class="post-list-item"><a class="post-list-link" href="/article/HBase架构和读写流程/">HBase架构和读写流程</a></li><li class="post-list-item"><a class="post-list-link" href="/article/HBase的Rowkey设计/">HBase的Rowkey设计</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/Spark/" style="font-size: 15px;">Spark</a> <a href="/tags/Hadoop/" style="font-size: 15px;">Hadoop</a> <a href="/tags/Scala/" style="font-size: 15px;">Scala</a> <a href="/tags/Kudu/" style="font-size: 15px;">Kudu</a> <a href="/tags/Flink/" style="font-size: 15px;">Flink</a> <a href="/tags/HBase/" style="font-size: 15px;">HBase</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/Shell/" style="font-size: 15px;">Shell</a> <a href="/tags/Flume/" style="font-size: 15px;">Flume</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/">2019</a><span class="archive-list-count">24</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/">2018</a><span class="archive-list-count">2</span></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"> <div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">暗也橙子.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/zzuUriel/zzuUriel.github.io"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.5"></script><div id="fullscreen-img" class="hide"><span class="close"></span></div><script type="text/javascript" src="/js/imgview.js?v=2.0.5" async></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.5" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>